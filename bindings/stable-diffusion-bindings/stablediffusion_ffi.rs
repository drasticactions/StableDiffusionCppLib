/* automatically generated by csbindgen */

#[allow(unused)]
use ::std::os::raw::*;

use super::stablediffusion::*;


#[no_mangle]
pub unsafe extern "C" fn csbindgen_memchr(
    __s: *const c_void,
    __c: c_int,
    __n: c_ulong
) -> *mut c_void
{
    memchr(
        __s,
        __c,
        __n
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_memcmp(
    __s1: *const c_void,
    __s2: *const c_void,
    __n: c_ulong
) -> c_int
{
    memcmp(
        __s1,
        __s2,
        __n
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_memcpy(
    __dst: *mut c_void,
    __src: *const c_void,
    __n: c_ulong
) -> *mut c_void
{
    memcpy(
        __dst,
        __src,
        __n
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_memmove(
    __dst: *mut c_void,
    __src: *const c_void,
    __len: c_ulong
) -> *mut c_void
{
    memmove(
        __dst,
        __src,
        __len
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_memset(
    __b: *mut c_void,
    __c: c_int,
    __len: c_ulong
) -> *mut c_void
{
    memset(
        __b,
        __c,
        __len
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_strcat(
    __s1: *mut c_char,
    __s2: *const c_char
) -> *mut c_char
{
    strcat(
        __s1,
        __s2
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_strchr(
    __s: *const c_char,
    __c: c_int
) -> *mut c_char
{
    strchr(
        __s,
        __c
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_strcmp(
    __s1: *const c_char,
    __s2: *const c_char
) -> c_int
{
    strcmp(
        __s1,
        __s2
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_strcoll(
    __s1: *const c_char,
    __s2: *const c_char
) -> c_int
{
    strcoll(
        __s1,
        __s2
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_strcpy(
    __dst: *mut c_char,
    __src: *const c_char
) -> *mut c_char
{
    strcpy(
        __dst,
        __src
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_strcspn(
    __s: *const c_char,
    __charset: *const c_char
) -> c_ulong
{
    strcspn(
        __s,
        __charset
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_strerror(
    __errnum: c_int
) -> *mut c_char
{
    strerror(
        __errnum
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_strlen(
    __s: *const c_char
) -> c_ulong
{
    strlen(
        __s
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_strncat(
    __s1: *mut c_char,
    __s2: *const c_char,
    __n: c_ulong
) -> *mut c_char
{
    strncat(
        __s1,
        __s2,
        __n
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_strncmp(
    __s1: *const c_char,
    __s2: *const c_char,
    __n: c_ulong
) -> c_int
{
    strncmp(
        __s1,
        __s2,
        __n
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_strncpy(
    __dst: *mut c_char,
    __src: *const c_char,
    __n: c_ulong
) -> *mut c_char
{
    strncpy(
        __dst,
        __src,
        __n
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_strpbrk(
    __s: *const c_char,
    __charset: *const c_char
) -> *mut c_char
{
    strpbrk(
        __s,
        __charset
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_strrchr(
    __s: *const c_char,
    __c: c_int
) -> *mut c_char
{
    strrchr(
        __s,
        __c
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_strspn(
    __s: *const c_char,
    __charset: *const c_char
) -> c_ulong
{
    strspn(
        __s,
        __charset
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_strstr(
    __big: *const c_char,
    __little: *const c_char
) -> *mut c_char
{
    strstr(
        __big,
        __little
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_strtok(
    __str: *mut c_char,
    __sep: *const c_char
) -> *mut c_char
{
    strtok(
        __str,
        __sep
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_strxfrm(
    __s1: *mut c_char,
    __s2: *const c_char,
    __n: c_ulong
) -> c_ulong
{
    strxfrm(
        __s1,
        __s2,
        __n
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_strtok_r(
    __str: *mut c_char,
    __sep: *const c_char,
    __lasts: *mut *mut c_char
) -> *mut c_char
{
    strtok_r(
        __str,
        __sep,
        __lasts
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_strerror_r(
    __errnum: c_int,
    __strerrbuf: *mut c_char,
    __buflen: usize
) -> c_int
{
    strerror_r(
        __errnum,
        __strerrbuf,
        __buflen
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_strdup(
    __s1: *const c_char
) -> *mut c_char
{
    strdup(
        __s1
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_memccpy(
    __dst: *mut c_void,
    __src: *const c_void,
    __c: c_int,
    __n: c_ulong
) -> *mut c_void
{
    memccpy(
        __dst,
        __src,
        __c,
        __n
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_stpcpy(
    __dst: *mut c_char,
    __src: *const c_char
) -> *mut c_char
{
    stpcpy(
        __dst,
        __src
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_stpncpy(
    __dst: *mut c_char,
    __src: *const c_char,
    __n: c_ulong
) -> *mut c_char
{
    stpncpy(
        __dst,
        __src,
        __n
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_strndup(
    __s1: *const c_char,
    __n: c_ulong
) -> *mut c_char
{
    strndup(
        __s1,
        __n
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_strnlen(
    __s1: *const c_char,
    __n: usize
) -> usize
{
    strnlen(
        __s1,
        __n
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_strsignal(
    __sig: c_int
) -> *mut c_char
{
    strsignal(
        __sig
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_memset_s(
    __s: *mut c_void,
    __smax: rsize_t,
    __c: c_int,
    __n: rsize_t
) -> errno_t
{
    memset_s(
        __s,
        __smax,
        __c,
        __n
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_memmem(
    __big: *const c_void,
    __big_len: usize,
    __little: *const c_void,
    __little_len: usize
) -> *mut c_void
{
    memmem(
        __big,
        __big_len,
        __little,
        __little_len
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_memset_pattern4(
    __b: *mut c_void,
    __pattern4: *const c_void,
    __len: usize
)
{
    memset_pattern4(
        __b,
        __pattern4,
        __len
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_memset_pattern8(
    __b: *mut c_void,
    __pattern8: *const c_void,
    __len: usize
)
{
    memset_pattern8(
        __b,
        __pattern8,
        __len
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_memset_pattern16(
    __b: *mut c_void,
    __pattern16: *const c_void,
    __len: usize
)
{
    memset_pattern16(
        __b,
        __pattern16,
        __len
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_strcasestr(
    __big: *const c_char,
    __little: *const c_char
) -> *mut c_char
{
    strcasestr(
        __big,
        __little
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_strnstr(
    __big: *const c_char,
    __little: *const c_char,
    __len: usize
) -> *mut c_char
{
    strnstr(
        __big,
        __little,
        __len
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_strlcat(
    __dst: *mut c_char,
    __source: *const c_char,
    __size: c_ulong
) -> c_ulong
{
    strlcat(
        __dst,
        __source,
        __size
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_strlcpy(
    __dst: *mut c_char,
    __source: *const c_char,
    __size: c_ulong
) -> c_ulong
{
    strlcpy(
        __dst,
        __source,
        __size
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_strmode(
    __mode: c_int,
    __bp: *mut c_char
)
{
    strmode(
        __mode,
        __bp
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_strsep(
    __stringp: *mut *mut c_char,
    __delim: *const c_char
) -> *mut c_char
{
    strsep(
        __stringp,
        __delim
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_swab(
    arg1: *const c_void,
    arg2: *mut c_void,
    arg3: isize
)
{
    swab(
        arg1,
        arg2,
        arg3
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_timingsafe_bcmp(
    __b1: *const c_void,
    __b2: *const c_void,
    __len: usize
) -> c_int
{
    timingsafe_bcmp(
        __b1,
        __b2,
        __len
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_strsignal_r(
    __sig: c_int,
    __strsignalbuf: *mut c_char,
    __buflen: usize
) -> c_int
{
    strsignal_r(
        __sig,
        __strsignalbuf,
        __buflen
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_bcmp(
    arg1: *const c_void,
    arg2: *const c_void,
    arg3: c_ulong
) -> c_int
{
    bcmp(
        arg1,
        arg2,
        arg3
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_bcopy(
    arg1: *const c_void,
    arg2: *mut c_void,
    arg3: usize
)
{
    bcopy(
        arg1,
        arg2,
        arg3
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_bzero(
    arg1: *mut c_void,
    arg2: c_ulong
)
{
    bzero(
        arg1,
        arg2
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_index(
    arg1: *const c_char,
    arg2: c_int
) -> *mut c_char
{
    index(
        arg1,
        arg2
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_rindex(
    arg1: *const c_char,
    arg2: c_int
) -> *mut c_char
{
    rindex(
        arg1,
        arg2
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ffs(
    arg1: c_int
) -> c_int
{
    ffs(
        arg1
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_strcasecmp(
    arg1: *const c_char,
    arg2: *const c_char
) -> c_int
{
    strcasecmp(
        arg1,
        arg2
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_strncasecmp(
    arg1: *const c_char,
    arg2: *const c_char,
    arg3: c_ulong
) -> c_int
{
    strncasecmp(
        arg1,
        arg2,
        arg3
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ffsl(
    arg1: c_long
) -> c_int
{
    ffsl(
        arg1
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ffsll(
    arg1: c_longlong
) -> c_int
{
    ffsll(
        arg1
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_fls(
    arg1: c_int
) -> c_int
{
    fls(
        arg1
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_flsl(
    arg1: c_long
) -> c_int
{
    flsl(
        arg1
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_flsll(
    arg1: c_longlong
) -> c_int
{
    flsll(
        arg1
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_sd_type_name(
    type_: sd_type_t
) -> *const c_char
{
    sd_type_name(
        type_
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_sd_set_log_callback(
    sd_log_cb: sd_log_cb_t,
    data: *mut c_void
)
{
    sd_set_log_callback(
        sd_log_cb,
        data
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_sd_set_progress_callback(
    cb: sd_progress_cb_t,
    data: *mut c_void
)
{
    sd_set_progress_callback(
        cb,
        data
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_get_num_physical_cores(

) -> i32
{
    get_num_physical_cores(

    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_sd_get_system_info(

) -> *const c_char
{
    sd_get_system_info(

    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_new_sd_ctx(
    model_path: *const c_char,
    vae_path: *const c_char,
    taesd_path: *const c_char,
    control_net_path_c_str: *const c_char,
    lora_model_dir: *const c_char,
    embed_dir_c_str: *const c_char,
    stacked_id_embed_dir_c_str: *const c_char,
    vae_decode_only: bool,
    vae_tiling: bool,
    free_params_immediately: bool,
    n_threads: c_int,
    wtype: sd_type_t,
    rng_type: rng_type_t,
    s: schedule_t,
    keep_clip_on_cpu: bool,
    keep_control_net_cpu: bool,
    keep_vae_on_cpu: bool
) -> *mut sd_ctx_t
{
    new_sd_ctx(
        model_path,
        vae_path,
        taesd_path,
        control_net_path_c_str,
        lora_model_dir,
        embed_dir_c_str,
        stacked_id_embed_dir_c_str,
        vae_decode_only,
        vae_tiling,
        free_params_immediately,
        n_threads,
        wtype,
        rng_type,
        s,
        keep_clip_on_cpu,
        keep_control_net_cpu,
        keep_vae_on_cpu
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_free_sd_ctx(
    sd_ctx: *mut sd_ctx_t
)
{
    free_sd_ctx(
        sd_ctx
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_txt2img(
    sd_ctx: *mut sd_ctx_t,
    prompt: *const c_char,
    negative_prompt: *const c_char,
    clip_skip: c_int,
    cfg_scale: f32,
    width: c_int,
    height: c_int,
    sample_method: sample_method_t,
    sample_steps: c_int,
    seed: i64,
    batch_count: c_int,
    control_cond: *const sd_image_t,
    control_strength: f32,
    style_strength: f32,
    normalize_input: bool,
    input_id_images_path: *const c_char
) -> *mut sd_image_t
{
    txt2img(
        sd_ctx,
        prompt,
        negative_prompt,
        clip_skip,
        cfg_scale,
        width,
        height,
        sample_method,
        sample_steps,
        seed,
        batch_count,
        control_cond,
        control_strength,
        style_strength,
        normalize_input,
        input_id_images_path
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_img2img(
    sd_ctx: *mut sd_ctx_t,
    init_image: sd_image_t,
    prompt: *const c_char,
    negative_prompt: *const c_char,
    clip_skip: c_int,
    cfg_scale: f32,
    width: c_int,
    height: c_int,
    sample_method: sample_method_t,
    sample_steps: c_int,
    strength: f32,
    seed: i64,
    batch_count: c_int,
    control_cond: *const sd_image_t,
    control_strength: f32,
    style_strength: f32,
    normalize_input: bool,
    input_id_images_path: *const c_char
) -> *mut sd_image_t
{
    img2img(
        sd_ctx,
        init_image,
        prompt,
        negative_prompt,
        clip_skip,
        cfg_scale,
        width,
        height,
        sample_method,
        sample_steps,
        strength,
        seed,
        batch_count,
        control_cond,
        control_strength,
        style_strength,
        normalize_input,
        input_id_images_path
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_img2vid(
    sd_ctx: *mut sd_ctx_t,
    init_image: sd_image_t,
    width: c_int,
    height: c_int,
    video_frames: c_int,
    motion_bucket_id: c_int,
    fps: c_int,
    augmentation_level: f32,
    min_cfg: f32,
    cfg_scale: f32,
    sample_method: sample_method_t,
    sample_steps: c_int,
    strength: f32,
    seed: i64
) -> *mut sd_image_t
{
    img2vid(
        sd_ctx,
        init_image,
        width,
        height,
        video_frames,
        motion_bucket_id,
        fps,
        augmentation_level,
        min_cfg,
        cfg_scale,
        sample_method,
        sample_steps,
        strength,
        seed
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_new_upscaler_ctx(
    esrgan_path: *const c_char,
    n_threads: c_int,
    wtype: sd_type_t
) -> *mut upscaler_ctx_t
{
    new_upscaler_ctx(
        esrgan_path,
        n_threads,
        wtype
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_free_upscaler_ctx(
    upscaler_ctx: *mut upscaler_ctx_t
)
{
    free_upscaler_ctx(
        upscaler_ctx
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_upscale(
    upscaler_ctx: *mut upscaler_ctx_t,
    input_image: sd_image_t,
    upscale_factor: u32
) -> sd_image_t
{
    upscale(
        upscaler_ctx,
        input_image,
        upscale_factor
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_convert(
    input_path: *const c_char,
    vae_path: *const c_char,
    output_path: *const c_char,
    output_type: sd_type_t
) -> bool
{
    convert(
        input_path,
        vae_path,
        output_path,
        output_type
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_preprocess_canny(
    img: *mut u8,
    width: c_int,
    height: c_int,
    high_threshold: f32,
    low_threshold: f32,
    weak: f32,
    strong: f32,
    inverse: bool
) -> *mut u8
{
    preprocess_canny(
        img,
        width,
        height,
        high_threshold,
        low_threshold,
        weak,
        strong,
        inverse
    )
}

    